metric;help;value;color;details;
experiment_type;;"Sequential";;;
user_time;"Percentage of the application time spent in user code (meaning the time spent in the binary and external libraries specified in custom_categories).";14.6;;;
iterations_count;"Optimistic speedup available by increasing the number of iterations in loops. Having low iteration count loops can decrease performances.\nLower is better.";"Not Available";bad;;
speedup_if_fully_vect;;;;;
compilation_flags;;"+ measure_gcc_O2: GNU C17 11.4.0 -mtune=generic -march=x86-64 -g -O2 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection  ";;;
speedup_if_perfect_openmp;"Optimistic speedup if OpenMP is perfectly balanced.\nLower is better.";"Not Available";bad;;
__name;;"run_0";;;
nb_loops_80_if_L1;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";"Not Available";bad;;
loops_time;"Percentage of the application time spent in loops (excluding loops present in modules not analyzed by the profiler). It represents 0.36 seconds.";14.2;;;
speedup_if_fp_vect;"Optimistic speedup if all floating point instructions are vectorized in all analyzed loops. Memory instructions are not considered as vectorized.\nLower is better.";1.002;good;;
speedup_if_perfect_MPI_OMP_PTHREAD_LOAD_DISTRIBUTION;"Optimistic speedup if OpenMP, MPI and Pthread runtimes are perfect and the load distribution if perfect.\nLower is better.\nThis metric presents an estimation of the speed-up at application level if most common parallel bottelnecks are perfect.\nspeedup = MAX (time) / AVG (time without OpenMP, MPI and Pthread)";1;good;;
speedup_if_perfect_MPI_OMP_PTHREAD;"Optimistic speedup if OpenMP, MPI and Pthread runtimes are perfect.\nLower is better.\nThis metric presents an estimation of the speed-up at application level if the MPI/OpenMP/Pthread behaviour is perfect.\nspeedup = MAX (time) / MAX (time without OpenMP, MPI and Pthread)";1;good;;
nb_loops_80_if_FP_only;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";2;;;
GFlops;"Giga FLOP (FLoating point OPeration) per second. Higher is better.\n";0;;;
speedup_if_L1;"Optimistic speedup if all memory accesses are located in the L1 cache for all analyzed loops.\nLower is better.";"Not Available";bad;;
GBs;"<TBD>.\n";"Not Implemented Yet";;;
nb_loops_80_if_fully_vect;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";2;;;
nb_loops_80_if_perfect_openmp;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";"Not Available";bad;;
nb_loops_80_if_clean;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
speedup_if_fully_vectorised;"Optimistic speedup if all instructions are vectorized in all analyzed loops.\nLower is better.";1.1297;acceptable;;
nb_loops_80_if_fp_vect;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
flow_complexity;"Optimistic speedup available by reducing the number of paths in loops. Having multiple paths in a loop can prevent the compiler to vectorize the code, decreasing performances. The metric provides an estimation of a global speedup that can be achieved if all loops with more than two paths were fully vectorized.\nLower is better.";1;good;;
speedup_if_clean;"Optimistic speedup if all instructions performing addresses computations and scalar integer computations have been deleted. \nLower is better.";1.0379;good;;
profiled_time;"Application profiling duration in seconds. A too low value means the profiling does not last long enough, and it could lead to an inaccurate profile.<br><b>Too short run</b>: statistical accuracy of profiling results is average (profiled time corresponds to 507 samples)<br><b>Workaround</b>: Rerun with a longer workload and/or use sampling-rate=high/highest in lprof_params";2.54;acceptable;99.28% of the total time;
array_access_efficiency;"Processor friendly data layout. Accessing contiguous data is faster.\nHigher is better.";73.31279342723;acceptable;;
crest_performance;"<TBD>.\n";"Not Implemented Yet";;;
number_processes;;1;;;
speedup_if_FP_only;"Optimistic speedup if only arithmetic floating point instructions are kept.\nLower is better.";1.0783;good;;
nb_threads;;1;;;
application_time;"Time spent by the application in seconds";2.558501958847;;;
compilation_options;"Global score based on basic options to use with the compiler to have good performance. Related report is based on the hottest profiled function, so it may not be fully representative of how each module was really compiled.";50;acceptable;;
innerloops_time;"Percentage of the application time spent in innermost loops (excluding loops present in modules not analyzed by the profiler). It represents 0.36 seconds.";14.2;;;
